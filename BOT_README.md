# Асинхронный python-bot для Telegram

Для взаимодействия с ботом необходимо использовать ссылку [@VKuziaShadPyBot](https://t.me/VKuziaShadPyBot).

## Использованные ресурсы

Бот использует ряд API для решения задачи. В первую очередь было написано обращение
к [TMDB](https://developers.themoviedb.org/3). С полученным API_KEY бот ходил на этот сервер и получал постер, название
и описание фильма на английском языке. Примечательно, что на английском поиск проходит по этой базе хорошо, а на русском
не очень. Решил попробовать ещё какую-нибудь апишку и наткнулся
на [неофициальный API кинопоиска](https://kinopoiskapiunofficial.tech/)

Оказалось, что его достаточно для выполнения условий задания, при этом зачастую в описании фильмов есть рейтинги imdb и
соответствующие айдишники.

Теперь бот использует информацию, получаемую с двух источников и объединяет по возможности всё в структурку, котора
транслируется пользователю.

Для поиска ссылок на кинотеатры первоначально была идея скрапить гугл, но после нескольких часов возни она отпала и я
решил использовать [SerpApi](https://serpapi.com/). Поискал руками пару удобных сайтов. После каждого удачного запроса о
фильме происходит два запроса в гугл для соотвествующих сайтов и подтягиваются первые ссылки. Классика вроде Форреста
Гампа или Побега из Шоушенка отлично работает.

В качестве базы данных используется sqlite3 в асинхронном варианте.

## Функционал

### HELP, START

Приветственные команды, которые помогают разобраться с использованием бота. Использование:

Использование:

```
/start
```

```
/help
```

### SEARCH [Keywords]

Основная команда бота, которая выполняет поиск по ключевым словам в базах TMDB и Кинопоиск. В принципе, поиск может
осуществляться на любом языке, я тестировал только русский и английский. Преимущество при выборе данных отдаётся API
кинопоиска, т.к. получается больше русскоязычной информации.

Полученная структура визуализируется в виде сообщения с постером (если такой был в базах) и отправляется пользователю. В
заивисомости от добытой информации сообщение может содержать:

* Название фильма
* Оригинальное название фильма
* Рейтинг imdb
* Рейтинг кинопоиска
* Описание фильма (преимущество за русским языком)
* Ссылка на страницу на кинопоиске
* Ссылка для просмотра онлайн в Источнике1
* Ссылка для просмотра онлайн в Источнике2

Использование:

```
/search Новый дом
```

```
/search Смешарики
```

Если ни кинопоиск, ни tmdb не предложили удовлетворительных вариантов, пользователь получает соответсвующее уведомление
с грустным смайликом.

## HISTORY

Возвращает пользователю историю удачных запросов в бота в следующем формате:

```
<дата и время поиска>: <текст поиска> -> "<Название фильма>"
```

Использование:

```
/history
```

### STATS

Возвращает пользователю список фильмов, которые ненулевое количество раз были успешно предложены ботом. Подсчитывает
количество таких раз в формате, сортирует фильмы по нему.

```
<Название фильма>: <Количество повторений в истории поиска>
```

Использование:

```
/stats
```

Неизвестные команды обрабатываются грустным смайликом.

## Устройство

bot_run.py запускает цикл выполнения бота, перенаправляет команды в реализацию BotApi, которая выполняет указанные
команды.

Используя передачу в поле, этой реализации подаются словарь поисковых движков, скраппер ссылок, бот, с помощью которого
можно передавать сообщения пользователю.

Все указанные сущности создаются в bot_run.py и прослоены интерфейсами для лучшей переиспользуемости. Честно говоря, не
уверен, что в интерфейсах была большая необходимость, но мне кажется, они чуть структурируют мой код. По итогу
получились единственные реализации интерфейсов Scrapper, BotDatabase.

BotApiImpl выполняет организационную работу по взаимодействию частей кода, управляет логикой поиска.

При поиске запрашиваются данные из обеих баз, если хотя бы в одной удалось что-то найти, то результаты сливаются и для
них ищутся к просмотру онлайн. Далее получившаяся структура парсится в текст с картинкой и отправляется пользователю.
Если выполнение успешно, в базу данных заносится запись о поиске.

BotDatabaseImpl использует асинхронные обращения к database.db, создавая таблицу, в которой хранятся строки вида

```
chat_id, text_searched, movie_title, kinopoisk_id, tmdb_id
```

Последние три используются для сбора статистики командой /stats в качестве идентификаторов фильма. Обращаю внимание на
то, что какие-то из этих полей могут быть null, но одновременно таковыми они быть не могут, поэтому и используются
втроём.

GoogleRestScrapper  используя RestApi выдаёт первую ссылку к просмотру фильма на указанном сайте.

Имплементации SearchEngine для кинописка и tmdb имеют схожие сценарии: в ходе поиска по ключевым словам получаем айдишники фильмов, а далее уточняем всю известную информацию о фильме запросом по этому айдишнику.
Имеет место разделение на два класса, так как ход взаимодействия с апи немного различается.

helpers.py, structs.py являются вспомогательными файлами со структурами, передаваемыми в ходе взаимодействия элементов бота и полезными функциями для их обработки.

## Итоги

Получился бот, который в среднем секунд за 4-5 выполняет запрос поиска фильма по двум базам. Львиную долю (по опыту больше половины) этого времени приходится отводить скраппингу первой ссылки гугла, т.к. поисковая страница выходит относительно тяжеловесной.
Без этого функционала бот работал намного быстрее, но как сделать более отказоустойчивый поиск онлайн-кинотеатра за разумное для лабы время, я не придумал :)

Сейчас бот прошёл деплой на Heroku и крутится засчёт моих бесплатных часов в режиме long_polling. По идее, он должен быть доступен в любое время в ближайшие несколько дней.

Хорошего дня :)
###